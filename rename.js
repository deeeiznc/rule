/**
 * ç”¨æ³•ï¼šSub-Store è„šæœ¬æ“ä½œæ·»åŠ 
 * rename.js ä»¥ä¸‹æ˜¯æ­¤è„šæœ¬æ”¯æŒçš„å‚æ•°ï¼Œå¿…é¡»ä»¥ # ä¸ºå¼€å¤´å¤šä¸ªå‚æ•°ä½¿ç”¨"&"è¿žæŽ¥ï¼Œå‚è€ƒä¸Šè¿°åœ°å€ä¸ºä¾‹ä½¿ç”¨å‚æ•°ã€‚ ç¦ç”¨ç¼“å­˜url#noCache
 *
 *** ä¸»è¦å‚æ•°
 * [in=] è‡ªåŠ¨åˆ¤æ–­æœºåœºèŠ‚ç‚¹åç±»åž‹ ä¼˜å…ˆçº§ zh(ä¸­æ–‡) -> flag(å›½æ——) -> quan(è‹±æ–‡å…¨ç§°) -> en(è‹±æ–‡ç®€å†™)
 * å¦‚æžœä¸å‡†çš„æƒ…å†µ, å¯ä»¥åŠ å‚æ•°æŒ‡å®š:
 *
 * [nm]    ä¿ç•™æ²¡æœ‰åŒ¹é…åˆ°çš„èŠ‚ç‚¹
 * [in=zh] æˆ–in=cnè¯†åˆ«ä¸­æ–‡
 * [in=en] æˆ–in=us è¯†åˆ«è‹±æ–‡ç¼©å†™
 * [in=flag] æˆ–in=gq è¯†åˆ«å›½æ—— å¦‚æžœåŠ å‚æ•° in=flag åˆ™è¯†åˆ«å›½æ—— è„šæœ¬æ“ä½œå‰é¢ä¸è¦æ·»åŠ å›½æ——æ“ä½œ å¦åˆ™ç§»é™¤å›½æ——åŽé¢è„šæœ¬è¯†åˆ«ä¸åˆ°
 * [in=quan] è¯†åˆ«è‹±æ–‡å…¨ç§°

 *
 * [out=]   è¾“å‡ºèŠ‚ç‚¹åå¯é€‰å‚æ•°: (cnæˆ–zh ï¼Œusæˆ–en ï¼Œgqæˆ–flag ï¼Œquan) å¯¹åº”ï¼š(ä¸­æ–‡ï¼Œè‹±æ–‡ç¼©å†™ ï¼Œå›½æ—— ï¼Œè‹±æ–‡å…¨ç§°) é»˜è®¤ä¸­æ–‡ ä¾‹å¦‚ [out=en] æˆ– out=us è¾“å‡ºè‹±æ–‡ç¼©å†™
 *** åˆ†éš”ç¬¦å‚æ•°
 *
 * [fgf=]   èŠ‚ç‚¹åå‰ç¼€æˆ–å›½æ——åˆ†éš”ç¬¦ï¼Œé»˜è®¤ä¸ºç©ºæ ¼ï¼›
 * [sn=]    è®¾ç½®å›½å®¶ä¸Žåºå·ä¹‹é—´çš„åˆ†éš”ç¬¦ï¼Œé»˜è®¤ä¸ºç©ºæ ¼ï¼›
 * åºå·å‚æ•°
 * [one]    æ¸…ç†åªæœ‰ä¸€ä¸ªèŠ‚ç‚¹çš„åœ°åŒºçš„01
 * [flag]   ç»™èŠ‚ç‚¹å‰é¢åŠ å›½æ——
 *
 *** å‰ç¼€å‚æ•°
 * [name=]  èŠ‚ç‚¹æ·»åŠ æœºåœºåç§°å‰ç¼€ï¼›
 * [nf]     æŠŠ name= çš„å‰ç¼€å€¼æ”¾åœ¨æœ€å‰é¢
 *** ä¿ç•™å‚æ•°
 * [blkey=iplc+gpt+NF+IPLC] ç”¨+å·æ·»åŠ å¤šä¸ªå…³é”®è¯ ä¿ç•™èŠ‚ç‚¹åçš„è‡ªå®šä¹‰å­—æ®µ éœ€è¦åŒºåˆ†å¤§å°å†™!
 * å¦‚æžœéœ€è¦ä¿®æ”¹ ä¿ç•™çš„å…³é”®è¯ æ›¿æ¢æˆåˆ«çš„ å¯ä»¥ç”¨ > åˆ†å‰² ä¾‹å¦‚ [#blkey=GPT>æ–°åå­—+å…¶ä»–å…³é”®è¯] è¿™å°†æŠŠã€GPTã€‘æ›¿æ¢æˆã€æ–°åå­—ã€‘
 * ä¾‹å¦‚      https://raw.githubusercontent.com/Keywos/rule/main/rename.js#flag&blkey=GPT>æ–°åå­—+NF
 * [blgd]   ä¿ç•™: å®¶å®½ IPLC Ë£Â² ç­‰
 * [bl]     æ­£åˆ™åŒ¹é…ä¿ç•™ [0.1x, x0.2, 6x ,3å€]ç­‰æ ‡è¯†
 * [nx]     ä¿ç•™1å€çŽ‡ä¸Žä¸æ˜¾ç¤ºå€çŽ‡çš„
 * [blnx]   åªä¿ç•™é«˜å€çŽ‡
 * [clear]  æ¸…ç†ä¹±å
 * [blpx]   å¦‚æžœç”¨äº†ä¸Šé¢çš„blå‚æ•°,å¯¹ä¿ç•™æ ‡è¯†åŽçš„åç§°åˆ†ç»„æŽ’åº,å¦‚æžœæ²¡ç”¨ä¸Šé¢çš„blå‚æ•°å•ç‹¬ä½¿ç”¨blpxåˆ™ä¸èµ·ä»»ä½•ä½œç”¨
 * [blockquic] blockquic=on é˜»æ­¢; blockquic=off ä¸é˜»æ­¢
 */

// const inArg = {'blkey':'iplc+GPT>GPTnewName+NF+IPLC', 'flag':true };
const inArg = $arguments; // console.log(inArg)
const nx = inArg.nx || false,
  bl = inArg.bl || false,
  nf = inArg.nf || false,
  key = inArg.key || false,
  blgd = inArg.blgd || false,
  blpx = inArg.blpx || false,
  blnx = inArg.blnx || false,
  numone = inArg.one || false,
  debug = inArg.debug || false,
  clear = inArg.clear || false,
  addflag = inArg.flag || false,
  nm = inArg.nm || false;

const FGF = inArg.fgf == undefined ? " " : decodeURI(inArg.fgf),
  XHFGF = inArg.sn == undefined ? " " : decodeURI(inArg.sn),
  FNAME = inArg.name == undefined ? "" : decodeURI(inArg.name),
  BLKEY = inArg.blkey == undefined ? "" : decodeURI(inArg.blkey),
  blockquic = inArg.blockquic == undefined ? "" : decodeURI(inArg.blockquic),
  nameMap = {
    cn: "cn",
    zh: "cn",
    us: "us",
    en: "us",
    quan: "quan",
    gq: "gq",
    flag: "gq",
  },
  inname = nameMap[inArg.in] || "",
  outputName = nameMap[inArg.out] || "";
// prettier-ignore
const FG = ['ðŸ‡­ðŸ‡°', 'ðŸ‡²ðŸ‡´', 'ðŸ‡¹ðŸ‡¼', 'ðŸ‡¯ðŸ‡µ', 'ðŸ‡°ðŸ‡·', 'ðŸ‡¸ðŸ‡¬', 'ðŸ‡ºðŸ‡¸', 'ðŸ‡¬ðŸ‡§', 'ðŸ‡«ðŸ‡·', 'ðŸ‡©ðŸ‡ª', 'ðŸ‡¦ðŸ‡º']l; // Omitted
// prettier-ignore
const EN = ['HK', 'MO', 'TW', 'JP', 'KR', 'SG', 'US', 'GB', 'FR', 'DE', 'AU'];
// prettier-ignore
const ZH = ['é¦™æ¸¯', 'æ¾³é—¨', 'å°æ¹¾', 'æ—¥æœ¬', 'éŸ©å›½', 'æ–°åŠ å¡', 'ç¾Žå›½', 'è‹±å›½', 'æ³•å›½', 'å¾·å›½', 'æ¾³å¤§åˆ©äºš'];
// prettier-ignore
const QC = ['Hong Kong', 'Macao', 'Taiwan', 'Japan', 'Korea', 'Singapore', 'United States', 'United Kingdom', 'France', 'Germany', 'Australia'];
const specialRegex = [
  /(\d\.)?\d+Ã—/,
  /IPLC|IEPL|Kern|Edge|Pro|Std|Exp|Biz|Fam|Game|Buy|Zx|LB|Game/,
];
const nameclear =
  /(å¥—é¤|åˆ°æœŸ|æœ‰æ•ˆ|å‰©ä½™|ç‰ˆæœ¬|å·²ç”¨|è¿‡æœŸ|å¤±è”|æµ‹è¯•|å®˜æ–¹|ç½‘å€|å¤‡ç”¨|ç¾¤|TEST|å®¢æœ|ç½‘ç«™|èŽ·å–|è®¢é˜…|æµé‡|æœºåœº|ä¸‹æ¬¡|å®˜å€|è”ç³»|é‚®ç®±|å·¥å•|å­¦æœ¯|æ–‡æ¡£|USE|USED|TOTAL|EXPIRE|EMAIL|TRAFFIC)/i;
// prettier-ignore
const regexArray = [/Ë£Â²/, /Ë£Â³/, /Ë£â´/, /Ë£âµ/, /Ë£â¶/, /Ë£â·/, /Ë£â¸/, /Ë£â¹/, /Ë£Â¹â°/, /Ë£Â²â°/, /Ë£Â³â°/, /Ë£â´â°/, /Ë£âµâ°/, /IPLC/i, /IEPL/i, /æ ¸å¿ƒ/, /è¾¹ç¼˜/, /é«˜çº§/, /æ ‡å‡†/, /å®žéªŒ/, /å•†å®½/, /å®¶å®½/, /æ¸¸æˆ|game/i, /è´­ç‰©/, /ä¸“çº¿/, /LB/, /cloudflare/i, /\budp\b/i, /\bgpt\b/i, /udpn\b/];
// prettier-ignore
const valueArray = ["2Ã—", "3Ã—", "4Ã—", "5Ã—", "6Ã—", "7Ã—", "8Ã—", "9Ã—", "10Ã—", "20Ã—", "30Ã—", "40Ã—", "50Ã—", "IPLC", "IEPL", "Kern", "Edge", "Pro", "Std", "Exp", "Biz", "Fam", "Game", "Buy", "Zx", "LB", "CF", "UDP", "GPT", "UDPN"];
const nameblnx = /(é«˜å€|(?!1)2+(x|å€)|Ë£Â²|Ë£Â³|Ë£â´|Ë£âµ|Ë£Â¹â°)/i;
const namenx = /(é«˜å€|(?!1)(0\.|\d)+(x|å€)|Ë£Â²|Ë£Â³|Ë£â´|Ë£âµ|Ë£Â¹â°)/i;
const keya =
  /æ¸¯|Hong|HK|æ–°åŠ å¡|SG|Singapore|æ—¥æœ¬|Japan|JP|ç¾Žå›½|United States|US|éŸ©|åœŸè€³å…¶|TR|Turkey|Korea|KR|ðŸ‡¸ðŸ‡¬|ðŸ‡­ðŸ‡°|ðŸ‡¯ðŸ‡µ|ðŸ‡ºðŸ‡¸|ðŸ‡°ðŸ‡·|ðŸ‡¹ðŸ‡·/i;
const keyb =
  /(((1|2|3|4)\d)|(é¦™æ¸¯|Hong|HK) 0[5-9]|((æ–°åŠ å¡|SG|Singapore|æ—¥æœ¬|Japan|JP|ç¾Žå›½|United States|US|éŸ©|åœŸè€³å…¶|TR|Turkey|Korea|KR) 0[3-9]))/i;
const rurekey = {
  GB: /UK/g,
  "B-G-P": /BGP/g,
  "Russia Moscow": /Moscow/g,
  "Korea Chuncheon": /Chuncheon|Seoul/g,
  "Hong Kong": /Hongkong|HONG KONG/gi,
  "United Kingdom London": /London|Great Britain/g,
  "Dubai United Arab Emirates": /United Arab Emirates/g,
  "Taiwan TW å°æ¹¾ ðŸ‡¹ðŸ‡¼": /(å°|Tai\s?wan|TW).*?ðŸ‡¨ðŸ‡³|ðŸ‡¨ðŸ‡³.*?(å°|Tai\s?wan|TW)/g,
  "United States": /USA|Los Angeles|San Jose|Silicon Valley|Michigan/g,
  æ¾³å¤§åˆ©äºš: /æ¾³æ´²|å¢¨å°”æœ¬|æ‚‰å°¼|åœŸæ¾³|(æ·±|æ²ª|å‘¼|äº¬|å¹¿|æ­)æ¾³/g,
  å¾·å›½: /(æ·±|æ²ª|å‘¼|äº¬|å¹¿|æ­)å¾·(?!.*(I|çº¿))|æ³•å…°å…‹ç¦|æ»¬å¾·/g,
  é¦™æ¸¯: /(æ·±|æ²ª|å‘¼|äº¬|å¹¿|æ­)æ¸¯(?!.*(I|çº¿))/g,
  æ—¥æœ¬: /(æ·±|æ²ª|å‘¼|äº¬|å¹¿|æ­|ä¸­|è¾½)æ—¥(?!.*(I|çº¿))|ä¸œäº¬|å¤§å‚/g,
  æ–°åŠ å¡: /ç‹®åŸŽ|(æ·±|æ²ª|å‘¼|äº¬|å¹¿|æ­)æ–°/g,
  ç¾Žå›½: /(æ·±|æ²ª|å‘¼|äº¬|å¹¿|æ­)ç¾Ž|æ³¢ç‰¹å…°|èŠåŠ å“¥|å“¥ä¼¦å¸ƒ|çº½çº¦|ç¡…è°·|ä¿„å‹’å†ˆ|è¥¿é›…å›¾|èŠåŠ å“¥/g,
  æ³¢æ–¯å°¼äºšå’Œé»‘å¡žå“¥ç»´é‚£: /æ³¢é»‘å…±å’Œå›½/g,
  å°å°¼: /å°åº¦å°¼è¥¿äºš|é›…åŠ è¾¾/g,
  å°åº¦: /å­Ÿä¹°/g,
  é˜¿è”é…‹: /è¿ªæ‹œ|é˜¿æ‹‰ä¼¯è”åˆé…‹é•¿å›½/g,
  å­ŸåŠ æ‹‰å›½: /å­ŸåŠ æ‹‰/g,
  æ·å…‹: /æ·å…‹å…±å’Œå›½/g,
  å°æ¹¾: /æ–°å°|æ–°åŒ—|å°(?!.*çº¿)/g,
  Taiwan: /Taipei/g,
  éŸ©å›½: /æ˜¥å·|éŸ©|é¦–å°”/g,
  Japan: /Tokyo|Osaka/g,
  è‹±å›½: /ä¼¦æ•¦/g,
  India: /Mumbai/g,
  Germany: /Frankfurt/g,
  Switzerland: /Zurich/g,
  ä¿„ç½—æ–¯: /èŽ«æ–¯ç§‘/g,
  åœŸè€³å…¶: /ä¼Šæ–¯å¦å¸ƒå°”/g,
  æ³°å›½: /æ³°åœ‹|æ›¼è°·/g,
  æ³•å›½: /å·´é»Ž/g,
  G: /\d\s?GB/gi,
  Esnc: /esnc/gi,
};

let GetK = false, AMK = []
function ObjKA(i) {
  GetK = true
  AMK = Object.entries(i)
}

function operator(pro) {
  const Allmap = {};
  const outList = getList(outputName);
  let inputList,
    retainKey = "";
  if (inname !== "") {
    inputList = [getList(inname)];
  } else {
    inputList = [ZH, FG, QC, EN];
  }

  inputList.forEach((arr) => {
    arr.forEach((value, valueIndex) => {
      Allmap[value] = outList[valueIndex];
    });
  });

  if (clear || nx || blnx || key) {
    pro = pro.filter((res) => {
      const resname = res.name;
      const shouldKeep =
        !(clear && nameclear.test(resname)) &&
        !(nx && namenx.test(resname)) &&
        !(blnx && !nameblnx.test(resname)) &&
        !(key && !(keya.test(resname) && /2|4|6|7/i.test(resname)));
      return shouldKeep;
    });
  }

  const BLKEYS = BLKEY ? BLKEY.split("+") : "";

  pro.forEach((e) => {
    let bktf = false, ens = e.name
    // é¢„å¤„ç† é˜²æ­¢é¢„åˆ¤æˆ–é—æ¼
    Object.keys(rurekey).forEach((ikey) => {
      if (rurekey[ikey].test(e.name)) {
        e.name = e.name.replace(rurekey[ikey], ikey);
        if (BLKEY) {
          bktf = true
          let BLKEY_REPLACE = "",
            re = false;
          BLKEYS.forEach((i) => {
            if (i.includes(">") && ens.includes(i.split(">")[0])) {
              if (rurekey[ikey].test(i.split(">")[0])) {
                e.name += " " + i.split(">")[0]
              }
              if (i.split(">")[1]) {
                BLKEY_REPLACE = i.split(">")[1];
                re = true;
              }
            } else {
              if (ens.includes(i)) {
                e.name += " " + i
              }
            }
            retainKey = re
              ? BLKEY_REPLACE
              : BLKEYS.filter((items) => e.name.includes(items));
          });
        }
      }
    });
    if (blockquic == "on") {
      e["block-quic"] = "on";
    } else if (blockquic == "off") {
      e["block-quic"] = "off";
    } else {
      delete e["block-quic"];
    }

    // è‡ªå®šä¹‰
    if (!bktf && BLKEY) {
      let BLKEY_REPLACE = "",
        re = false;
      BLKEYS.forEach((i) => {
        if (i.includes(">") && e.name.includes(i.split(">")[0])) {
          if (i.split(">")[1]) {
            BLKEY_REPLACE = i.split(">")[1];
            re = true;
          }
        }
      });
      retainKey = re
        ? BLKEY_REPLACE
        : BLKEYS.filter((items) => e.name.includes(items));
    }

    let ikey = "",
      ikeys = "";
    // ä¿ç•™å›ºå®šæ ¼å¼ å€çŽ‡
    if (blgd) {
      regexArray.forEach((regex, index) => {
        if (regex.test(e.name)) {
          ikeys = valueArray[index];
        }
      });
    }

    // æ­£åˆ™ åŒ¹é…å€çŽ‡
    if (bl) {
      const match = e.name.match(
        /((å€çŽ‡|X|x|Ã—)\D?((\d{1,3}\.)?\d+)\D?)|((\d{1,3}\.)?\d+)(å€|X|x|Ã—)/
      );
      if (match) {
        const rev = match[0].match(/(\d[\d.]*)/)[0];
        if (rev !== "1") {
          const newValue = rev + "Ã—";
          ikey = newValue;
        }
      }
    }

    !GetK && ObjKA(Allmap)
    // åŒ¹é… Allkey åœ°åŒº
    const findKey = AMK.find(([key]) =>
      e.name.includes(key)
    )

    let firstName = "",
      nNames = "";

    if (nf) {
      firstName = FNAME;
    } else {
      nNames = FNAME;
    }
    if (findKey?.[1]) {
      const findKeyValue = findKey[1];
      let keyover = [],
        usflag = "";
      if (addflag) {
        const index = outList.indexOf(findKeyValue);
        if (index !== -1) {
          usflag = FG[index];
          usflag = usflag === "ðŸ‡¹ðŸ‡¼" ? "ðŸ‡¨ðŸ‡³" : usflag;
        }
      }
      keyover = keyover
        .concat(firstName, usflag, nNames, findKeyValue, retainKey, ikey, ikeys)
        .filter((k) => k !== "");
      e.name = keyover.join(FGF);
    } else {
      // æ–°å¢žå¤‡ç”¨æŸ¥æ‰¾é€»è¾‘
      const match = e.name.match(/[æ¾³å¾·æ¸¯æ—¥æ–°å¡ç¾Žå°éŸ©ä¿„æ³°æ³•]/);
      if (match) {
        const findKeyValue = {
          "æ¾³": "AU", "å¾·": "DE", "æ¸¯": "HK", "æ—¥": "JP", "å¡": "SG", "ç¾Ž": "US", "å°": "TW", "éŸ©": "KR", "ä¿„": "RU", "æ³°": "TH", "æ³•": "FR"
        }[match[0]];

        let usflag = "";
        if (addflag) {
          const index = outList.indexOf(findKeyValue);
          usflag = index !== -1 ?
            (FG[index] === "ðŸ‡¹ðŸ‡¼" ? "ðŸ‡¨ðŸ‡³" : FG[index]) : "";
        }
        const keyParts = [firstName, usflag, nNames, findKeyValue, retainKey, ikey, ikeys].filter(Boolean);
        e.name = keyParts.join(FGF);
      } else if (nm) {
        e.name = FNAME + FGF + e.name;
      } else {
        e.name = null;
      }
    }
    pro = pro.filter((e) => e.name !== null);
    jxh(pro);
    numone && oneP(pro);
    blpx && (pro = fampx(pro));
    key && (pro = pro.filter((e) => !keyb.test(e.name)));
    return pro;
  }

// prettier-ignore
function getList(arg) { switch (arg) { case 'us': return EN; case 'gq': return FG; case 'quan': return QC; default: return ZH; } }
// prettier-ignore
function jxh(e) { const n = e.reduce((e, n) => { const t = e.find((e) => e.name === n.name); if (t) { t.count++; t.items.push({ ...n, name: `${n.name}${XHFGF}${t.count.toString().padStart(2, "0")}`, }); } else { e.push({ name: n.name, count: 1, items: [{ ...n, name: `${n.name}${XHFGF}01` }], }); } return e; }, []); const t = (typeof Array.prototype.flatMap === 'function' ? n.flatMap((e) => e.items) : n.reduce((acc, e) => acc.concat(e.items), [])); e.splice(0, e.length, ...t); return e; }
// prettier-ignore
function oneP(e) { const t = e.reduce((e, t) => { const n = t.name.replace(/[^A-Za-z0-9\u00C0-\u017F\u4E00-\u9FFF]+\d+$/, ""); if (!e[n]) { e[n] = []; } e[n].push(t); return e; }, {}); for (const e in t) { if (t[e].length === 1 && t[e][0].name.endsWith("01")) {/* const n = t[e][0]; n.name = e;*/ t[e][0].name = t[e][0].name.replace(/[^.]01/, "") } } return e; }
// prettier-ignore
function fampx(pro) { const wis = []; const wnout = []; for (const proxy of pro) { const fan = specialRegex.some((regex) => regex.test(proxy.name)); if (fan) { wis.push(proxy); } else { wnout.push(proxy); } } const sps = wis.map((proxy) => specialRegex.findIndex((regex) => regex.test(proxy.name))); wis.sort((a, b) => sps[wis.indexOf(a)] - sps[wis.indexOf(b)] || a.name.localeCompare(b.name)); wnout.sort((a, b) => pro.indexOf(a) - pro.indexOf(b)); return wnout.concat(wis); }
